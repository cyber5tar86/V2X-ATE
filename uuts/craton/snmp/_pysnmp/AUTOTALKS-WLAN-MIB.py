# PySNMP SMI module. Autogenerated from smidump -f python AUTOTALKS-WLAN-MIB
# by libsmi2pysnmp-0.1.3 at Tue Aug  4 15:19:14 2015,
# Python version sys.version_info(major=2, minor=7, micro=6, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( atlkMgmt, ) = mibBuilder.importSymbols("AUTOTALKS-REG", "atlkMgmt")
( ConfigSaveStatus, ) = mibBuilder.importSymbols("AUTOTALKS-TC", "ConfigSaveStatus")
( InterfaceIndex, ifIndex, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "ifIndex")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Integer32, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32")
( MacAddress, RowStatus, TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "RowStatus", "TextualConvention", "TruthValue")

# Types

class WlanEdcaIndex(TextualConvention, Integer32):
    displayHint = "d"
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(1,1020)
    
class WlanLoLeakageIndex(TextualConvention, Integer32):
    displayHint = "d"
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(1,4080)
    
class WlanPantLut(TextualConvention, OctetString):
    displayHint = "1500a"
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(512,1500)
    
class WlanPantLutDbm8Index(TextualConvention, Integer32):
    displayHint = "d"
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(1,1024)
    
class WlanRfIndex(TextualConvention, Integer32):
    displayHint = "d"
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(1,255)
    

# Objects

wlanMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 38405, 1, 1)).setRevisions(("2015-07-28 00:00","2015-07-22 00:00","2015-07-21 00:00","2015-07-16 00:00","2015-07-13 00:00","2015-06-22 00:00","2015-06-11 00:00","2015-06-09 00:00","2015-03-03 00:00","2015-01-14 00:00","2014-12-22 00:00","2014-10-27 00:00","2014-10-26 00:00","2014-06-18 00:00","2014-05-13 00:00","2014-04-30 00:00","2014-03-11 00:00","2014-02-10 00:00","2014-02-06 00:00","2013-12-18 00:00","2013-12-04 00:00","2013-04-21 00:00","2012-06-24 00:00","2012-05-14 00:00",))
if mibBuilder.loadTexts: wlanMib.setOrganization("Autotalks")
if mibBuilder.loadTexts: wlanMib.setContactInfo("Grand Netter Building\nPOB 3846, Kfar-Netter 40593, Israel\nPhone: (+972)-9-886-5300\nFax:   (+972)-9-886-5301\ninfo@auto-talks.com")
if mibBuilder.loadTexts: wlanMib.setDescription("CRATON WLAN MIB definition.")
wlanConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 38405, 1, 1, 1))
wlanGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 38405, 1, 1, 1, 1))
wlanCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 38405, 1, 1, 1, 2))
wlanSmt = MibIdentifier((1, 3, 6, 1, 4, 1, 38405, 1, 1, 2))
wlanConfigSaveStatus = MibScalar((1, 3, 6, 1, 4, 1, 38405, 1, 1, 2, 1), ConfigSaveStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanConfigSaveStatus.setDescription("WLAN configuration save status.")
wlanMac = MibIdentifier((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3))
wlanMacTable = MibTable((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 1))
if mibBuilder.loadTexts: wlanMacTable.setDescription("MAC interfaces configuration table.")
wlanMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 1, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: wlanMacEntry.setDescription("MAC interfaces configuration entry.")
wlanDefaultTxDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(6, 108))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanDefaultTxDataRate.setDescription("Default transmission data rate.")
wlanDefaultTxPower = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-30, 33))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanDefaultTxPower.setDescription("Default transmission power.")
wlanRandomBackoffEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 1, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRandomBackoffEnabled.setDescription("Whether MAC transmission random backoff is enabled.")
wlanMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 1, 1, 4), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanMacAddress.setDescription("802.11 MAC Address.\n\nPlease note that MAC frame queues are not flushed when the address\nis changed, meaning that the previous address value may appear as\noutgoing frame source address or incoming destination address (in the\ncase of unicast frames) some time after the change.")
wlanTxSaOverrideEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 1, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanTxSaOverrideEnabled.setDescription("Whether source address override is enabled.\n\nIf enabled, source MAC address (SA) can be set arbitrarily per frame\ntransmission by upper layer, without changing wlanMacAddress.")
wlanRxUcastDaFilterEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 1, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRxUcastDaFilterEnabled.setDescription("Whether unicast destination address filter is enabled.\n\nIf enabled, MAC will drop unicast frames which have destination\nMAC address different from the receiving station MAC address.")
wlanShortRetryLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanShortRetryLimit.setDescription("This attribute indicates the maximum number of transmission attempts\nof a frame, the length of which is less than or equal to RTSThreshold,\nthat is made before a failure condition is indicated.")
wlanDefaultTxPowerDbm8 = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-240, 264))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanDefaultTxPowerDbm8.setDescription("Default transmission power in 1/8 dBm.")
wlanMacCntTable = MibTable((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 2))
if mibBuilder.loadTexts: wlanMacCntTable.setDescription("MAC counters table.")
wlanMacCntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 2, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: wlanMacCntEntry.setDescription("MAC counters entry.")
wlanFrameTxCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanFrameTxCnt.setDescription("This counter shall be incremented for each transmitted frame.")
wlanFrameRxCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanFrameRxCnt.setDescription("This counter shall be incremented for each correctly received frame.")
wlanTxFailCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanTxFailCnt.setDescription("This counter shall be incremented for each failure during frame\ntransmission.")
wlanTxAllocFailCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanTxAllocFailCnt.setDescription("This counter shall be incremented for each memory allocation failure\nduring frame transmission.")
wlanTxQueueFailCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanTxQueueFailCnt.setDescription("This counter shall be incremented for each queuing failure during\nframe transmission.")
wlanRxFailCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanRxFailCnt.setDescription("This counter shall be incremented for each failure during frame\nreceival.")
wlanRxAllocFailCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanRxAllocFailCnt.setDescription("This counter shall be incremented for each memory allocation failure\nduring frame receival.")
wlanRxQueueFailCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanRxQueueFailCnt.setDescription("This counter shall be incremented for each queuing failure during\nframe receival.")
wlanMacDiversity = MibIdentifier((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 3))
wlanRxDuplicateFrameFilteringEnabled = MibScalar((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 3, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRxDuplicateFrameFilteringEnabled.setDescription("Whether MAC duplicate frame filtering is enabled in RX diversity mode.")
wlanEdcaTable = MibTable((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 4))
if mibBuilder.loadTexts: wlanEdcaTable.setDescription("EDCA configuration table.")
wlanEdcaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 4, 1)).setIndexNames((0, "AUTOTALKS-WLAN-MIB", "wlanEdcaIndex"))
if mibBuilder.loadTexts: wlanEdcaEntry.setDescription("EDCA configuration entry.")
wlanEdcaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 4, 1, 1), WlanEdcaIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: wlanEdcaIndex.setDescription("Identifies row of EDCA table.")
wlanEdcaCWmin = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanEdcaCWmin.setDescription("The minimum size of the window that is used for generating a random\nnumber for the backoff.\n\nThe value of this attribute is such that it could always be expressed\nin the form of 2**X - 1, where X is an integer.")
wlanEdcaCWmax = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 4, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanEdcaCWmax.setDescription("The maximum size of the window that is used for generating a random\nnumber for the backoff.\n\nThe value of this attribute is such that it could always be expressed\nin the form of 2**X - 1, where X is an integer.")
wlanCsTable = MibTable((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 5))
if mibBuilder.loadTexts: wlanCsTable.setDescription("Channel switching control table.\n\nEach interface can be placed in a channel switching mode regardless\nof the state in which the other interface is.\n\nChannel switching is performed between channel A and B as set by \nwlanCsFrequencyA and wlanCsFrequencyB respectively\n\nOnce channel switching is activated, setting the interface frequency \nusing  wlanFrequency, wlanPresetFrequency0 or wlanPresetFrequency1 \nwill result in undefined behavior.\n\nIn the event that channel switching is halted, due to a user disable\nrequest or loss of synchronization with reference clock, the interface  \nwill automatically revert the interface to channel A.\n\nThe activation of channel switching is only possible if all row attributes  \nare set to valid values. ")
wlanCsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 5, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: wlanCsEntry.setDescription("Channel switching control table entry.")
wlanCsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 5, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCsRowStatus.setDescription("Status of channel switching. Supported values are \n(see wlanCsTable for more details):\n* active       - Enable channel switching on the interface. \n* notInService - Channel switching is disabled  \n* notReady     - The request to activate channel switching, on the\n                 interface, could not be completed since one of the\n                 row attributes is invalid.")
wlanCsFrequencyA = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5180, 5930))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCsFrequencyA.setDescription("Frequency to be used, by Channel A, in channel switching. \n\nIf the user intends to use current interface frequency as channel A \nfrequency it should be read by wlanFrequency and set to this attribute. \n\nThe attribute can only be set if wlanCsRowStatus is set to \n'notInService'.")
wlanCsFrequencyB = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5180, 5930))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCsFrequencyB.setDescription("Frequency to be used, by Channel B, in channel switching. \n\nThe attribute can only be set if wlanCsRowStatus is set to \n'notInService'.")
wlanCsIntervalA = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCsIntervalA.setDescription("Channel A interval")
wlanCsIntervalB = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCsIntervalB.setDescription("Channel B interval")
wlanCsSyncTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanCsSyncTolerance.setDescription(" This attribute is equivalent to SyncTolerance as defined in IEEE \n1609.4-2010 clause 6.2.5. \n\nIf the system clock skews from the reference clock by more than\nhalf of the SyncTolerance value, channel switching will be halted\nand the interface will revert to channel A.")
wlanCsIfIndexB = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 3, 5, 1, 7), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanCsIfIndexB.setDescription("Interface index for channel B, when channel switching is active.")
wlanPhy = MibIdentifier((1, 3, 6, 1, 4, 1, 38405, 1, 1, 4))
wlanTxDiversity = MibIdentifier((1, 3, 6, 1, 4, 1, 38405, 1, 1, 4, 1))
wlanTxDiversityEnabled = MibScalar((1, 3, 6, 1, 4, 1, 38405, 1, 1, 4, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanTxDiversityEnabled.setDescription("Whether TX diversity is enabled.")
wlanTxCsd = MibScalar((1, 3, 6, 1, 4, 1, 38405, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite").setUnits("samples")
if mibBuilder.loadTexts: wlanTxCsd.setDescription("Cyclic shift delay to the transmitted OFDM symbol.")
wlanRxDiversity = MibIdentifier((1, 3, 6, 1, 4, 1, 38405, 1, 1, 4, 2))
wlanRxDiversityEnabled = MibScalar((1, 3, 6, 1, 4, 1, 38405, 1, 1, 4, 2, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRxDiversityEnabled.setDescription("Whether RX diversity is enabled.")
wlanRxDiversityCnt = MibScalar((1, 3, 6, 1, 4, 1, 38405, 1, 1, 4, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanRxDiversityCnt.setDescription("RX diversity counter.")
wlanPhyTable = MibTable((1, 3, 6, 1, 4, 1, 38405, 1, 1, 4, 3))
if mibBuilder.loadTexts: wlanPhyTable.setDescription("PHY interfaces configuration table.")
wlanPhyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 38405, 1, 1, 4, 3, 1)).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: wlanPhyEntry.setDescription("PHY interfaces configuration entry.")
wlanChannelProbingInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanChannelProbingInterval.setDescription("Channel load probing interval.")
wlanChannelLoadThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-95, -35))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanChannelLoadThreshold.setDescription("Threshold of received signal strength above which the channel will\nbe considered busy.")
wlanChannelBusyRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanChannelBusyRatio.setDescription("The percentage of time during which the channel was busy in the last\nprobing interval.")
wlanRf = MibIdentifier((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5))
wlanRfTable = MibTable((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 1))
if mibBuilder.loadTexts: wlanRfTable.setDescription("RF interfaces table.")
wlanRfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 1, 1)).setIndexNames((0, "AUTOTALKS-WLAN-MIB", "wlanRfIndex"))
if mibBuilder.loadTexts: wlanRfEntry.setDescription("RF interface entry.")
wlanRfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 1, 1, 1), WlanRfIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: wlanRfIndex.setDescription("Identifies RF interface.")
wlanFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5180, 5930))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanFrequency.setDescription("Current frequency.\n\nChanging frequency value is faster when new frequency value has been\npreset, otherwise preset frequency 1 is set and used.")
wlanDcocStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,0,2,)).subtype(namedValues=NamedValues(("notStarted", 0), ("inProgress", 1), ("success", 2), ("failure", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanDcocStatus.setDescription("Indicates status of DCOC (DC Offset Cancellation) process.")
wlanRfFrontEndConnected = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRfFrontEndConnected.setDescription("Whether an external RF front-end is connected.")
wlanRfEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 1, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRfEnabled.setDescription("Whether RF interface is enabled. Once an interface has been\ndisabled, it can only be re-enabled by rebooting the unit.")
wlanRfFrontEndOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRfFrontEndOffset.setDescription("Attenuation of the first transmitted frame's output power.\nRelevant only when a RF front-end is used.")
wlanPhyOFDMChannelWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 1, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("width10MHz", 1), ("width20MHz", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPhyOFDMChannelWidth.setDescription("Current PHY OFDM channel width.")
wlanPresetFrequency0 = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5180, 5930))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPresetFrequency0.setDescription("Preset frequency 0.")
wlanPresetFrequency1 = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5180, 5930))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPresetFrequency1.setDescription("Preset frequency 1.")
wlanDcocEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 1, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanDcocEnabled.setDescription("Whether periodic DCOC is enabled.")
wlanRssiLatestFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanRssiLatestFrame.setDescription("RSSI of latest frame received at PHY.")
wlanRficTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-200, 200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanRficTemperature.setDescription("RFIC temperature.")
wlanRfTestTable = MibTable((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 2))
if mibBuilder.loadTexts: wlanRfTestTable.setDescription("RF interfaces test table, augments wlanRfTable.")
wlanRfTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 2, 1))
if mibBuilder.loadTexts: wlanRfTestEntry.setDescription("RF interface test entry.")
wlanRfTestMode = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 2, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,0,)).subtype(namedValues=NamedValues(("off", 0), ("random", 1), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRfTestMode.setDescription("RF interface test mode.")
wlanRfCalibration = MibIdentifier((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3))
wlanRfCalibrationTable = MibTable((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1))
if mibBuilder.loadTexts: wlanRfCalibrationTable.setDescription("WLAN RF calibration table.")
wlanRfCalibrationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1, 1)).setIndexNames((0, "AUTOTALKS-WLAN-MIB", "wlanRfIndex"))
if mibBuilder.loadTexts: wlanRfCalibrationEntry.setDescription("WLAN RF calibration table entry.")
wlanTssiPintercept = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanTssiPintercept.setDescription("Intercept of the line equation used to evaluate output power.")
wlanTssiPslope = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanTssiPslope.setDescription("Slope of the line equation used to evaluate output power.")
wlanTssiInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanTssiInterval.setDescription("TSSI sampling interval.")
wlanRxSampleGainLow = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1280, 1270))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRxSampleGainLow.setDescription("Low-range input power gain correction factor.")
wlanRxSampleGainMid = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1280, 1270))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRxSampleGainMid.setDescription("Mid-range input power gain correction factor.")
wlanRxSampleGainHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1280, 1270))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRxSampleGainHigh.setDescription("High-range input power gain correction factor.")
wlanGrfiSignalDelayResolution = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanGrfiSignalDelayResolution.setDescription("Timing resolution of the delay between transmitted packets to PA\nand T/R RF switch.")
wlanRxIqImbalanceAmplitude = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-60, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRxIqImbalanceAmplitude.setDescription("Received signal I/Q imbalance amplitude correction factor.")
wlanRxIqImbalancePhase = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanRxIqImbalancePhase.setDescription("Received signal I/Q imbalance phase correction factor.")
wlanTxIqImbalanceAmplitude = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-60, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanTxIqImbalanceAmplitude.setDescription("Transmitted signal I/Q imbalance amplitude correction factor.")
wlanTxIqImbalancePhase = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-100, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanTxIqImbalancePhase.setDescription("Transmitted signal I/Q imbalance phase correction factor.")
wlanPantLutIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPantLutIndex.setDescription("Which power antenna LUT entry is used.")
wlanTssiDetectorReading = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wlanTssiDetectorReading.setDescription("ADC TSSI feedback detector reading.")
wlanPantLutTable = MibTable((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 2))
if mibBuilder.loadTexts: wlanPantLutTable.setDescription("WLAN RF power antenna LUT table.")
wlanPantLutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 2, 1)).setIndexNames((0, "AUTOTALKS-WLAN-MIB", "wlanRfIndex"))
if mibBuilder.loadTexts: wlanPantLutEntry.setDescription("WLAN RF power antenna LUT entry.")
wlanPantLut = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 2, 1, 1), WlanPantLut()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPantLut.setDescription("Lookup table (LUT) for conversion of power detector output\ninto 1 dBm.")
wlanLoLeakageTable = MibTable((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 3))
if mibBuilder.loadTexts: wlanLoLeakageTable.setDescription("LO leakage table")
wlanLoLeakageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 3, 1)).setIndexNames((0, "AUTOTALKS-WLAN-MIB", "wlanLoLeakageIndex"))
if mibBuilder.loadTexts: wlanLoLeakageEntry.setDescription("WLAN LO leakage calibration table entry.")
wlanLoLeakageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 3, 1, 1), WlanLoLeakageIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: wlanLoLeakageIndex.setDescription("Identifies row of wlanLoLeakageTable.")
wlanLoLeakage = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanLoLeakage.setDescription("LO leakage cancellation per gain.")
wlanPantLutDbm8Table = MibTable((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 4))
if mibBuilder.loadTexts: wlanPantLutDbm8Table.setDescription("WLAN RF power antenna LUT Dbm8 table.")
wlanPantLutDbm8Entry = MibTableRow((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 4, 1)).setIndexNames((0, "AUTOTALKS-WLAN-MIB", "wlanPantLutDbm8Index"))
if mibBuilder.loadTexts: wlanPantLutDbm8Entry.setDescription("WLAN RF power antenna LUT entry.")
wlanPantLutDbm8Index = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 4, 1, 1), WlanPantLutDbm8Index()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: wlanPantLutDbm8Index.setDescription("Identifies element in LutDbm8.")
wlanPantLutDbm8 = MibTableColumn((1, 3, 6, 1, 4, 1, 38405, 1, 1, 5, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-80, 320))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wlanPantLutDbm8.setDescription("Lookup table (LUT) for conversion of power detector output\ninto 1/8 dBm.")

# Augmentions
wlanRfEntry.registerAugmentions(("AUTOTALKS-WLAN-MIB", "wlanRfTestEntry"))
wlanRfTestEntry.setIndexNames(*wlanRfEntry.getIndexNames())

# Groups

wlanMibGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 38405, 1, 1, 1, 1, 1)).setObjects(*(("AUTOTALKS-WLAN-MIB", "wlanRxAllocFailCnt"), ("AUTOTALKS-WLAN-MIB", "wlanRxDiversityEnabled"), ("AUTOTALKS-WLAN-MIB", "wlanRandomBackoffEnabled"), ("AUTOTALKS-WLAN-MIB", "wlanCsRowStatus"), ("AUTOTALKS-WLAN-MIB", "wlanFrameRxCnt"), ("AUTOTALKS-WLAN-MIB", "wlanRxFailCnt"), ("AUTOTALKS-WLAN-MIB", "wlanRxDiversityCnt"), ("AUTOTALKS-WLAN-MIB", "wlanRfFrontEndOffset"), ("AUTOTALKS-WLAN-MIB", "wlanChannelBusyRatio"), ("AUTOTALKS-WLAN-MIB", "wlanDcocStatus"), ("AUTOTALKS-WLAN-MIB", "wlanCsFrequencyA"), ("AUTOTALKS-WLAN-MIB", "wlanTxSaOverrideEnabled"), ("AUTOTALKS-WLAN-MIB", "wlanChannelLoadThreshold"), ("AUTOTALKS-WLAN-MIB", "wlanFrequency"), ("AUTOTALKS-WLAN-MIB", "wlanCsIntervalA"), ("AUTOTALKS-WLAN-MIB", "wlanCsIntervalB"), ("AUTOTALKS-WLAN-MIB", "wlanRssiLatestFrame"), ("AUTOTALKS-WLAN-MIB", "wlanFrameTxCnt"), ("AUTOTALKS-WLAN-MIB", "wlanConfigSaveStatus"), ("AUTOTALKS-WLAN-MIB", "wlanDefaultTxDataRate"), ("AUTOTALKS-WLAN-MIB", "wlanRxDuplicateFrameFilteringEnabled"), ("AUTOTALKS-WLAN-MIB", "wlanRficTemperature"), ("AUTOTALKS-WLAN-MIB", "wlanChannelProbingInterval"), ("AUTOTALKS-WLAN-MIB", "wlanCsFrequencyB"), ("AUTOTALKS-WLAN-MIB", "wlanRfTestMode"), ("AUTOTALKS-WLAN-MIB", "wlanMacAddress"), ("AUTOTALKS-WLAN-MIB", "wlanTxDiversityEnabled"), ("AUTOTALKS-WLAN-MIB", "wlanRfEnabled"), ("AUTOTALKS-WLAN-MIB", "wlanTxQueueFailCnt"), ("AUTOTALKS-WLAN-MIB", "wlanTxFailCnt"), ("AUTOTALKS-WLAN-MIB", "wlanPhyOFDMChannelWidth"), ("AUTOTALKS-WLAN-MIB", "wlanDefaultTxPower"), ("AUTOTALKS-WLAN-MIB", "wlanShortRetryLimit"), ("AUTOTALKS-WLAN-MIB", "wlanEdcaCWmax"), ("AUTOTALKS-WLAN-MIB", "wlanEdcaCWmin"), ("AUTOTALKS-WLAN-MIB", "wlanRxQueueFailCnt"), ("AUTOTALKS-WLAN-MIB", "wlanRxUcastDaFilterEnabled"), ("AUTOTALKS-WLAN-MIB", "wlanTxAllocFailCnt"), ("AUTOTALKS-WLAN-MIB", "wlanTxCsd"), ("AUTOTALKS-WLAN-MIB", "wlanCsSyncTolerance"), ("AUTOTALKS-WLAN-MIB", "wlanRfFrontEndConnected"), ("AUTOTALKS-WLAN-MIB", "wlanCsIfIndexB"), ) )
if mibBuilder.loadTexts: wlanMibGroup.setDescription("RFIC-independent WLAN management objects.")
wlanPlutonMibGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 38405, 1, 1, 1, 1, 2)).setObjects(*(("AUTOTALKS-WLAN-MIB", "wlanPantLut"), ("AUTOTALKS-WLAN-MIB", "wlanPresetFrequency1"), ("AUTOTALKS-WLAN-MIB", "wlanTxIqImbalancePhase"), ("AUTOTALKS-WLAN-MIB", "wlanPantLutIndex"), ("AUTOTALKS-WLAN-MIB", "wlanRxIqImbalancePhase"), ("AUTOTALKS-WLAN-MIB", "wlanTssiDetectorReading"), ("AUTOTALKS-WLAN-MIB", "wlanLoLeakage"), ("AUTOTALKS-WLAN-MIB", "wlanRxSampleGainMid"), ("AUTOTALKS-WLAN-MIB", "wlanRxIqImbalanceAmplitude"), ("AUTOTALKS-WLAN-MIB", "wlanTssiPslope"), ("AUTOTALKS-WLAN-MIB", "wlanRxSampleGainHigh"), ("AUTOTALKS-WLAN-MIB", "wlanRxSampleGainLow"), ("AUTOTALKS-WLAN-MIB", "wlanPresetFrequency0"), ("AUTOTALKS-WLAN-MIB", "wlanGrfiSignalDelayResolution"), ("AUTOTALKS-WLAN-MIB", "wlanPantLutDbm8"), ("AUTOTALKS-WLAN-MIB", "wlanDcocEnabled"), ("AUTOTALKS-WLAN-MIB", "wlanTssiPintercept"), ("AUTOTALKS-WLAN-MIB", "wlanTssiInterval"), ("AUTOTALKS-WLAN-MIB", "wlanTxIqImbalanceAmplitude"), ) )
if mibBuilder.loadTexts: wlanPlutonMibGroup.setDescription("PLUTON RFIC-specific WLAN management objects.")

# Compliances

wlanCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 38405, 1, 1, 1, 2, 1)).setObjects(*(("AUTOTALKS-WLAN-MIB", "wlanPlutonMibGroup"), ("AUTOTALKS-WLAN-MIB", "wlanMibGroup"), ) )
if mibBuilder.loadTexts: wlanCompliance.setDescription("Compliance statement covering entire AUTOTALKS-WLAN-MIB.")

# Exports

# Module identity
mibBuilder.exportSymbols("AUTOTALKS-WLAN-MIB", PYSNMP_MODULE_ID=wlanMib)

# Types
mibBuilder.exportSymbols("AUTOTALKS-WLAN-MIB", WlanEdcaIndex=WlanEdcaIndex, WlanLoLeakageIndex=WlanLoLeakageIndex, WlanPantLut=WlanPantLut, WlanPantLutDbm8Index=WlanPantLutDbm8Index, WlanRfIndex=WlanRfIndex)

# Objects
mibBuilder.exportSymbols("AUTOTALKS-WLAN-MIB", wlanMib=wlanMib, wlanConformance=wlanConformance, wlanGroups=wlanGroups, wlanCompliances=wlanCompliances, wlanSmt=wlanSmt, wlanConfigSaveStatus=wlanConfigSaveStatus, wlanMac=wlanMac, wlanMacTable=wlanMacTable, wlanMacEntry=wlanMacEntry, wlanDefaultTxDataRate=wlanDefaultTxDataRate, wlanDefaultTxPower=wlanDefaultTxPower, wlanRandomBackoffEnabled=wlanRandomBackoffEnabled, wlanMacAddress=wlanMacAddress, wlanTxSaOverrideEnabled=wlanTxSaOverrideEnabled, wlanRxUcastDaFilterEnabled=wlanRxUcastDaFilterEnabled, wlanShortRetryLimit=wlanShortRetryLimit, wlanDefaultTxPowerDbm8=wlanDefaultTxPowerDbm8, wlanMacCntTable=wlanMacCntTable, wlanMacCntEntry=wlanMacCntEntry, wlanFrameTxCnt=wlanFrameTxCnt, wlanFrameRxCnt=wlanFrameRxCnt, wlanTxFailCnt=wlanTxFailCnt, wlanTxAllocFailCnt=wlanTxAllocFailCnt, wlanTxQueueFailCnt=wlanTxQueueFailCnt, wlanRxFailCnt=wlanRxFailCnt, wlanRxAllocFailCnt=wlanRxAllocFailCnt, wlanRxQueueFailCnt=wlanRxQueueFailCnt, wlanMacDiversity=wlanMacDiversity, wlanRxDuplicateFrameFilteringEnabled=wlanRxDuplicateFrameFilteringEnabled, wlanEdcaTable=wlanEdcaTable, wlanEdcaEntry=wlanEdcaEntry, wlanEdcaIndex=wlanEdcaIndex, wlanEdcaCWmin=wlanEdcaCWmin, wlanEdcaCWmax=wlanEdcaCWmax, wlanCsTable=wlanCsTable, wlanCsEntry=wlanCsEntry, wlanCsRowStatus=wlanCsRowStatus, wlanCsFrequencyA=wlanCsFrequencyA, wlanCsFrequencyB=wlanCsFrequencyB, wlanCsIntervalA=wlanCsIntervalA, wlanCsIntervalB=wlanCsIntervalB, wlanCsSyncTolerance=wlanCsSyncTolerance, wlanCsIfIndexB=wlanCsIfIndexB, wlanPhy=wlanPhy, wlanTxDiversity=wlanTxDiversity, wlanTxDiversityEnabled=wlanTxDiversityEnabled, wlanTxCsd=wlanTxCsd, wlanRxDiversity=wlanRxDiversity, wlanRxDiversityEnabled=wlanRxDiversityEnabled, wlanRxDiversityCnt=wlanRxDiversityCnt, wlanPhyTable=wlanPhyTable, wlanPhyEntry=wlanPhyEntry, wlanChannelProbingInterval=wlanChannelProbingInterval, wlanChannelLoadThreshold=wlanChannelLoadThreshold, wlanChannelBusyRatio=wlanChannelBusyRatio, wlanRf=wlanRf, wlanRfTable=wlanRfTable, wlanRfEntry=wlanRfEntry, wlanRfIndex=wlanRfIndex, wlanFrequency=wlanFrequency, wlanDcocStatus=wlanDcocStatus, wlanRfFrontEndConnected=wlanRfFrontEndConnected, wlanRfEnabled=wlanRfEnabled, wlanRfFrontEndOffset=wlanRfFrontEndOffset, wlanPhyOFDMChannelWidth=wlanPhyOFDMChannelWidth, wlanPresetFrequency0=wlanPresetFrequency0, wlanPresetFrequency1=wlanPresetFrequency1, wlanDcocEnabled=wlanDcocEnabled, wlanRssiLatestFrame=wlanRssiLatestFrame, wlanRficTemperature=wlanRficTemperature, wlanRfTestTable=wlanRfTestTable, wlanRfTestEntry=wlanRfTestEntry, wlanRfTestMode=wlanRfTestMode, wlanRfCalibration=wlanRfCalibration, wlanRfCalibrationTable=wlanRfCalibrationTable, wlanRfCalibrationEntry=wlanRfCalibrationEntry, wlanTssiPintercept=wlanTssiPintercept, wlanTssiPslope=wlanTssiPslope, wlanTssiInterval=wlanTssiInterval, wlanRxSampleGainLow=wlanRxSampleGainLow, wlanRxSampleGainMid=wlanRxSampleGainMid, wlanRxSampleGainHigh=wlanRxSampleGainHigh, wlanGrfiSignalDelayResolution=wlanGrfiSignalDelayResolution, wlanRxIqImbalanceAmplitude=wlanRxIqImbalanceAmplitude, wlanRxIqImbalancePhase=wlanRxIqImbalancePhase, wlanTxIqImbalanceAmplitude=wlanTxIqImbalanceAmplitude, wlanTxIqImbalancePhase=wlanTxIqImbalancePhase, wlanPantLutIndex=wlanPantLutIndex, wlanTssiDetectorReading=wlanTssiDetectorReading, wlanPantLutTable=wlanPantLutTable, wlanPantLutEntry=wlanPantLutEntry, wlanPantLut=wlanPantLut, wlanLoLeakageTable=wlanLoLeakageTable, wlanLoLeakageEntry=wlanLoLeakageEntry, wlanLoLeakageIndex=wlanLoLeakageIndex, wlanLoLeakage=wlanLoLeakage, wlanPantLutDbm8Table=wlanPantLutDbm8Table, wlanPantLutDbm8Entry=wlanPantLutDbm8Entry, wlanPantLutDbm8Index=wlanPantLutDbm8Index, wlanPantLutDbm8=wlanPantLutDbm8)

# Groups
mibBuilder.exportSymbols("AUTOTALKS-WLAN-MIB", wlanMibGroup=wlanMibGroup, wlanPlutonMibGroup=wlanPlutonMibGroup)

# Compliances
mibBuilder.exportSymbols("AUTOTALKS-WLAN-MIB", wlanCompliance=wlanCompliance)
